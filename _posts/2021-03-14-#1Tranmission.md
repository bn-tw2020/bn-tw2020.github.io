---
layout: post
title: "전송계층 & UDP"
categories: 네트워크
author: bn-tw2020
---
* content
{:toc}


## Intro

```
네트워크를 정리하는 글입니다.
```





---

## 전송계층

어플리케이션은 OS가 제공하는 서비스를 사용하는 계층이라고 생각하면된다.  
UDP, TCP라는 서비스를 사용해서 정보를 다른 컴퓨터에게 보낸다라고 알고 있다.  

이번엔 UDP, TCP를 사용해서 어떻게 보내는지에 학습을 할 것이다.  
전송 계층은 OS내부에 구현이 되어있다.  

```
전송 계층은 어플리케이션 계층에서 데이터를 받아서 다른 편에 있는 어플리케이션에 전달하는 것이다.
논리적으로보면, 편지를 작성해서 우체통에 넣으면 상대방 편지함에 도착한다라고 생각을 하면된다.
네트워크 내부에는 현재 어떻게 돌아가는지는 모른다.

전송계층에서는 라우터가 어떻게 작동하는지에 대해 상관이없다.
그저 다른 컴퓨터에 프로세스에 도달하는 논리적인 관계에 관심을 갖는다!
```

```
어플리케이션 계층에서 만들어지는 데이터의 단위를 메시지라고 표현을 한다.
전송 계층으로 내려오게 되면, 전송 계층에서 사용하는 전송 단위인 세그먼트에 메세지가 들어오게 되고,
           메타 데이터 + 어플리케이션 계층의 메시지가 된다.
           즉, 편지봉투(세그먼트)에 편지지가 들어간다고 생각하면 될것이다.
               편지봉투에 적힌 주소가 메타 데이터가 된다.

그 후에 세그먼트가 네트워크 계층에 내려가게 되면, 네트워크 전송 단위인 패킷의 내부로 세그먼트가 들어간다.
                위에서 말한 메타 데이터 + 전송 계층 단위인 세그먼트로 된다.
```

### TCP • UDP

```
전송 계층은 TCP, UDP가 존재하며,
TCP는 사용자가 보내는 메시지가 유실되거나 수정되지 않고 도달하며(reliable), 사용자 보내는 메시지 순서대로 도착한다.(in-order)
     사용자가 메시지를 보내는데 1G를 보낸다고 치며, 보내는 속도는 보내는 사람이 선택한다.
     얼마나 빠른 속도로 보내는지, 얼마나 느리게 보내는지는 2가지 요소에 의해 결정이 된다.
       1. 상대방이 받아들일 수 있는 속도가 어느정도인가? ⟹ 흐름제어(Flow control)
       2. 현재 네트워크의 상태가 어느정도인가? ⟹ 네트워크속도에 맞춰서보내주는 혼잡제어(Congestion Control) 
          (목적지 컴퓨터는 슈퍼컴퓨터인데 네트워크가 막혀있다.)

UDP는 아무 것도 하지 않는다. 그래서 unreliable, unordered delivery이다.
```

#### Multiplexing • demultiplexing

<img width="482" alt="스크린샷 2021-03-14 오후 6 20 47" src="https://user-images.githubusercontent.com/66770613/111063474-01146d00-84f2-11eb-98c9-32a1acaaf701.png">  

```
하나의 컴퓨터에서 여러 프로세스가 존재하는데 프로세스가 네트워크를 사용한다면 각자의 소켓을 가지고 있을 것이다.
내려오는 길은 하나이다. 그래서 전송 계층에서 멀티 플레싱이 이루어진다.
멀티 플레싱은 여러 군데에서 정보를 받아서 하나의 통로로 내린다는 것이다.

multi는 간단하게 ↓ ↓ ↓ ↓ ↓
              ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯  여러 갈랫길에서 나와서 하나의 통로로 간다.
                  ↓

Demulti는 간단하게 ↑ ↑ ↑ ↑ ↑
                ⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯⎯  반대로 생각하면 된다.
                    ↑

이 과정이 전송계층에서 이루어진다. 왜냐하면 전송계층은 결국 소켓 인터페이스를 다루는 계층이기 때문이다.


멀티플레싱은 나와서 한 곳으로 들어가지만,
디멀티플레싱은 컴퓨터 내의 어느 프로세스의 어느 소켓으로 보내야 하는 결정을 해야하는데, 이 과정에 포트번호가 필요한 것이다.

UDP는 포트 번호만 보고 디멀티플렉싱이 이루어진다. dest port만 본다.
TCP 디멀티플레싱은 source IP Address, source Port Number, dest IP Address, dest Port Number이 필요하다.
    전체 4개를 다 파악해서 디멀티플렉싱이 이루어진다.
    하나라도 값이 다르면 다른 소켓이된다.

why? UDP 디멀티플렉싱과 차이가 존재하지?
     TCP소켓은 1:1 대응이고, 사용자의 요청이 있을 때마다 스레드를 만들어서 소켓처리한다. 따라서 해당 스레드가 소켓을 처리한다.
```

#### UDP

```
UDP는 위에서 아무런 기능을 제공하지 않는다고 했다.
하지만, 기능 하나를 하고 있는 것이였다. 바로 멀티 플레싱과 디 멀티 플레싱이다.

어떤 계층에서 특정 계층을 수행하기 위해서는 수행하기 위한 정보가 필요하다.
그 정보들은 헤더에 적히게 된다.

멀티 플레싱, 디 멀티 플레싱을 하기 위핸 정보는 source port, dest port인것이다.
그리고 그 이외의 것은 제공하지 않는다.

그래서 가볍다. Connection을 맺기 위한 여러 절차를 거치지 않는다.
```

<img width="296" alt="스크린샷 2021-03-14 오후 7 01 22" src="https://user-images.githubusercontent.com/66770613/111064498-ad0c8700-84f7-11eb-8b94-a2884e3baf17.png">  

* UDP는 헤더 필드가 source port, dest port, length, checksum이 존재한다.

* 프로토콜의 헤더는 해당 목적지에 실질적으로 필요한 부분이 아니다.
    * 데이터만 필요할 뿐, 사용자에게 전달을 해야하니..
    * 크기가 클수록 오버헤드의 부담이 커지기 때문에 프로토콜을 디자인을 할 때 헤더를 줄이려는 노력을 해야한다.
    * !즉, 헤더에 어떤 필드들이 들어가있는지 이해한다면, 해당 프로토콜이 어떤 동작을 하는지 간접적인 이해가 가능하다.

* port number : 디멀티플레싱할 때 사용한다.
* checksum : 전송 중에 에러가 있는지 판단하게 된다. 중간에 데이터 전송 중 에러가 생겼는지 알 수 있게 해준다.
             에러가 생긴 메시지가 있다면 드랍해버린다.

## Reference

[웹 동작 원리](https://bn-tw2020.github.io/2021/02/16/2_WebStream/)  
