---
layout: post
title: "TCP(2)"
categories: 네트워크
author: bn-tw2020
---
* content
{:toc}


## Intro

```
네트워크를 정리하는 글입니다.
```





---

## TCP

```
패킷에러가 생길 수 있는 네트워크에서는 어떤 매커니즘을 사용하면 극복할까?
  1. Error Detection
  2. Feed-back
  3. Re-Transmission
  4. Time-out

If) 패킷에러와 유실이 동시에 일어난 경우라면?

Example) 친구랑 전화 통화중 ..
         친구랑 이야기하다가 도중에 메시지가 유실이되면 아무소리도 들리지 않을 것이다.
         그럼 긴장감이 흐르다가.. 누군가 말을 할것이다.
         즉, 나도 모르는 마음속의 타이머가 있다는 것이다.

유실된 경우에는 타이머가 필요하다. 
패킷을 전송할 때 타이머가 필요하다. 타이머가 만료되기 이전에 피드백을 받으면 정상,
만료되기 이전에 피드백을 받지 못하면 데이터가 유실됬음을 인지할 수 있다. 그래서 sender가 다시 해당 패킷을 보낸다.
```
<img width="658" alt="스크린샷 2021-03-15 오후 5 47 44" src="https://user-images.githubusercontent.com/66770613/111126898-8cefcd00-85b6-11eb-9f45-8dbac2796224.png">  

<img width="658" alt="스크린샷 2021-03-15 오후 5 47 23" src="https://user-images.githubusercontent.com/66770613/111126858-81040b00-85b6-11eb-9547-09004acebe6f.png">  
  
<br><br>

* Stop And Wait Operation(Stop & Wait)

![스크린샷 2021-03-15 오후 5 53 45](https://user-images.githubusercontent.com/66770613/111127645-667e6180-85b7-11eb-9381-d252829dec00.png)  

위의 그림처럼 하나씩 보내게 되면, 비효율적이다.  
왜냐하면 패킷을 하나 보내고 다시 하나 받는 그러한 과정 속에서 오버헤드가 발생하기 때문이다.  
아래의 그림처럼 Pipelining을 실시해줘야 한다. 즉 한번에 패킷을 받고 한번에 Feedback를 받는 형태

![스크린샷 2021-03-15 오후 5 54 01](https://user-images.githubusercontent.com/66770613/111127681-6f6f3300-85b7-11eb-8b7a-b536447b3b08.png)  


### TCP Overview

* point to point
* reliable, in-order btye
* pipelined
* full duplex data
    * sender & receiver라는 개념 자체가 사실 송신도하면서 수신도하기 때문에 상호간 데이터가 이동
* TCP Segment

### TCP Segment Structure

<img width="502" alt="스크린샷 2021-03-15 오후 6 00 31" src="https://user-images.githubusercontent.com/66770613/111128526-57e47a00-85b8-11eb-9e7b-05b589552b9c.png">  

```
Why?) TCP & UDP 헤더필드는 중요할까?
      해당 프로토콜을 한번에 이해할 수 있으니깐..

source & dest port : 멀티플레싱과 디멀티플레싱을 하기 위함.
sequence number : ACKs & NAKs을 통해서 트랙킹하기 위함
acknowledgement number : 각각이 송수신자이기 때문에 sequence number이다.

TPC의 송수신자는 버퍼를 2개를 가지고 있다.
  1. send buffer
     애플리케이션에서 데이터를 보내려고 하는 버퍼.
     버퍼 내부에서 송신되는 세그먼트는 수신 측의 리시브 버퍼에 측에 쌓인다.
  2. receive buffer
     반대 측에서 보내는 데이터들이 해당 리시브 버퍼에 쌓인다.

버퍼의 존재이유??
  1. In-order byte를 가능케한다.
  2. error dection을 위함(checksum)
  3. flow control을 하기 위함(receive window)
     수신 측의 리시브 버퍼를 확인하기 위해 사용
```

```
TCP에서 사용하는 시퀀스 번호
제일 앞에 있는 바이트번호가 sequence number가 된다.
ACK#10은 9번 시퀀스까지 잘받았고 10번 시퀀스 번호를 갖는 데이터를 갖는다.
```


## Reference

[웹 동작 원리](https://bn-tw2020.github.io/2021/02/16/2_WebStream/)  
